/**
 * queryBuilder module.
 * @module framework/lib/queryBuilder
 */
var _ = require("lodash");

var presetQueryParams = new RegExp(
  "^searchProperty|searchValue|searchOperator|sortProperty|sortDirection|" +
    "pageSize|pageNumber|filter|includes|join|_dc|sort|api_key|fq$"
);

var API_KEY = "api_key";
var operatorTest = new RegExp(
  "^in$|^eq$|^ne$|^lt$|^gt$|^le$|^ge$|^ct$|^bw$|^ew$|^like$|^IN$|^EQ$|^NE$|^LT$|^GT$|" +
    "^LE$|^GE$|^CT$|^BW$|^EW$|^LIKE$/"
);

var directionTest = /^asc$|^desc$|^ASC$|^DESC$/;

/**
 * Takes the query string object and transforms it into our
 * standard query object. The query string object generated by
 * https://github.com/Gozala/querystring is used by most engines including
 * express and restify.
 * @param query {object} The query string object generated by querystring.
 * @returns serviceBusQuery {object} : New query object standardized for the service bus
 * @throws ValidationException
 */
exports.buildQuery = function (q) {
  var newQuery = transformQuery(q);
  validateQuery(newQuery);
  return processQuery(newQuery);
};

/**
 * Takes the query string object and remaps any arbitrary parameters into
 * standard query object parameters; moving arbitrary parameters into
 * searchProperty, searchOperator, and searchValue
 * @param query {object} The query string object
 * @returns query {object} : A querystring query object with arbitrary parameters remapped.
 */
function transformQuery(q) {
  var outerBracketsRE = /^\[(.+)\]$/;
  var transformedQuery = {};
  var newQueryParams = {};

  /**
   * If property exists copy it to new query object
   * @param property
   */
  function copyIfExists(property) {
    if (q[property]) {
      transformedQuery[property] = q[property];
    }
  }

  /**
   * Adds the property and ensures it's an array
   * @param {string} property - name of the property
   * @param {string} value - value to add
   */
  function checkAndAdd(property, value) {
    var currentvalue = transformedQuery[property];

    if (currentvalue && !Array.isArray(currentvalue)) {
      transformedQuery[property] = [currentvalue];
    }

    if (currentvalue) {
      transformedQuery[property].push(value);
    } else {
      transformedQuery[property] = [value];
    }
  }

  /**
   * Add the search property to the query object
   * @param {string} searchProperty
   * @param {string} searchOperator
   * @param {string} searchValue
   */
  function addSearchProperty(searchProperty, searchOperator, searchValue) {
    checkAndAdd("searchProperty", searchProperty);
    checkAndAdd("searchOperator", searchOperator);
    checkAndAdd("searchValue", searchValue);
  }

  copyIfExists("searchProperty");
  copyIfExists("searchOperator");
  copyIfExists("searchValue");
  copyIfExists("pageSize");
  copyIfExists("pageNumber");
  copyIfExists("sortProperty");
  copyIfExists("sortDirection");
  copyIfExists("filter");
  copyIfExists("includes");
  copyIfExists("join");

  _.each(q, function (value, key) {
    var matchOuterBrackets;

    if (!key.match(presetQueryParams)) {
      // not a predefined query parameter - transform
      if ((matchOuterBrackets = outerBracketsRE.exec(value))) {
        var terms = matchOuterBrackets[1].split(",");

        if (terms.length >= 2) {
          if (terms[0] === "in") {
            addSearchProperty(key, terms[0], terms.slice(1).join(","));
          } else {
            addSearchProperty(key, terms[0], terms[1]);
          }
        } else {
          /** we've got one term, assume == */
          addSearchProperty(key, "eq", terms[0]);
        }
      } else {
        /** no brackets - just default eq */
        addSearchProperty(key, "eq", value);
      }
    }
  });

  return transformedQuery;
}

/**
 * Validate the query object for correctness
 * @param query {object} The querystring parsed query object
 * @throws ValidationException
 */
function validateQuery(q) {
  var ctr;
  var length;
  var exceptionMessage = null;

  if (q.pageSize || q.pageSize) {
    if (q.pageSize && isNaN(q.pageSize)) {
      exceptionMessage = "Query parameters invalid: pageSize require numbers";
    }
  }

  if (q.pageNumber) {
    if (q.pageNumber && isNaN(q.pageNumber)) {
      exceptionMessage = "Query parameters invalid: pageNumber require numbers";
    }
  }

  if (q.join) {
    if (q.join.toUpperCase() !== "OR" && q.join.toUpperCase() !== "AND") {
      exceptionMessage = "Query parameters invalid: join must be AND or OR";
    }
  }

  if (
    (q.searchProperty && !q.searchValue) ||
    (q.searchValue && !q.searchProperty) ||
    (Array.isArray(q.searchProperty) && !Array.isArray(q.searchValue)) ||
    (!Array.isArray(q.searchProperty) && Array.isArray(q.searchValue)) ||
    (Array.isArray(q.searchProperty) &&
      Array.isArray(q.searchValue) &&
      q.searchProperty.length != q.searchValue.length)
  ) {
    exceptionMessage =
      "Query parameters invalid: must have matching number of SearchProperties and SearchValues";
  }

  if (q.searchOperator) {
    if (Array.isArray(q.searchOperator)) {
      length = q.searchOperator.length;

      if (
        !q.searchProperty ||
        !q.searchValue ||
        (Array.isArray(q.searchProperty) && q.searchProperty.length != length)
      ) {
        // note that SearchValues and SearchProperties have already been validated
        // there is no need to check SearchValues.length
        exceptionMessage =
          "Query parameters invalid: number of SearchOperators must " +
          "match number of search properties";
      }

      for (ctr = 0; ctr < length; ctr++) {
        if (operatorTest.exec(q.searchOperator[ctr]) === null) {
          exceptionMessage =
            "Query parameters invalid: SearchOperators must " +
            "be in eq, ne, gt, lt, ge, le, ct, in, bw or ew.";
        }
      }
    } else {
      if (
        !q.searchProperty ||
        !q.searchValue ||
        Array.isArray(q.searchProperty)
      ) {
        exceptionMessage =
          "Query parameters invalid: searchOperator must have " +
          "matching searchProperty and searchValue";
      }

      if (operatorTest.exec(q.searchOperator) === null) {
        exceptionMessage =
          "Query parameters invalid: SearchOperators " +
          "must be in eq, ne, gt, lt, ge, le, ct, in, bw or ew";
      }
    }
  }

  if (
    (q.sortProperty && !q.sortDirection) ||
    (q.sortDirection && !q.sortProperty) ||
    (Array.isArray(q.sortProperty) && !Array.isArray(q.sortDirection)) ||
    (!Array.isArray(q.sortProperty) && Array.isArray(q.sortDirection)) ||
    (Array.isArray(q.sortProperty) &&
      Array.isArray(q.sortDirection) &&
      q.sortProperty.length != q.sortDirection.length)
  ) {
    exceptionMessage =
      "Query parameters invalid: must have matching number of SortProperties and SortDirections";
  }

  if (q.sortDirection) {
    if (Array.isArray(q.sortDirection)) {
      length = q.sortDirection.length;

      for (ctr = 0; ctr < length; ctr++) {
        if (directionTest.exec(q.sortDirection[ctr]) === null) {
          exceptionMessage =
            "Query parameters invalid: sortDirection must be asc or desc";
        }
      }
    } else {
      if (directionTest.exec(q.sortDirection) === null) {
        exceptionMessage =
          "Query parameters invalid: sortDirection must be asc or desc";
      }
    }
  }

  if (exceptionMessage !== null) {
    throw {
      exception: "ValidationException",
      message: exceptionMessage,
    };
  }
}

/**
 * Generate a standard query object
 * @param query {object} query string object from querystring
 * @returns serviceBusQuery {object} : a standardized nextgen query object
 */
function processQuery(q) {
  var query = {};
  var searchLength = 0;
  var sortLength = 0;
  var isSearchOperatorArray = false;
  var i = 0;

  if (q.pageNumber || q.pageSize) {
    query.pageNumber = q.pageNumber || 1;
    query.pageSize = q.pageSize || 10;
  }

  if (q.join) {
    query.join = q.join.toUpperCase();
  }

  if (q.searchProperty) {
    query.search = [];
    // If multiple properties, you must have multiple values
    if (Array.isArray(q.searchProperty) && Array.isArray(q.searchValue)) {
      isSearchOperatorArray =
        q.searchOperator && Array.isArray(q.searchOperator);
      searchLength = q.searchProperty.length;

      for (i = 0; i < searchLength; i++) {
        // unless both prop and value, ignore
        if (q.searchProperty[i] && q.searchValue[i]) {
          query.search[i] = {};
          query.search[i].searchProperty = q.searchProperty[i];
          query.search[i].searchValue = q.searchValue[i];
          query.search[i].searchOperator =
            isSearchOperatorArray && q.searchOperator[i]
              ? q.searchOperator[i]
              : "==";
        }
      }
    } else if (q.searchProperty && q.searchValue) {
      query.search[0] = {};
      query.search[0].searchProperty = q.searchProperty;
      query.search[0].searchValue = q.searchValue;
      query.search[0].searchOperator = q.searchOperator || "eq";
    }
  }

  if (q.sortProperty) {
    query.sort = [];
    // If multiple properties, you must have multiple directions
    if (Array.isArray(q.sortProperty) && Array.isArray(q.sortDirection)) {
      sortLength = q.sortProperty.length;

      for (i = 0; i < sortLength; i++) {
        // unless both prop and value, ignore
        if (q.sortProperty[i] && q.sortDirection[i]) {
          query.sort[i] = {};
          query.sort[i].sortProperty = q.sortProperty[i];
          query.sort[i].sortDirection = q.sortDirection[i].toUpperCase();
        }
      }
    } else if (q.sortProperty && q.sortDirection) {
      query.sort[0] = {};
      query.sort[0].sortProperty = q.sortProperty;
      query.sort[0].sortDirection = q.sortDirection.toUpperCase();
    }
  }

  if (q.filter) {
    if (Array.isArray(q.filter)) {
      query.filter = q.filter;
    } else {
      query.filter = q.filter.split(",");
    }
  }

  if (q.includes) {
    if (Array.isArray(q.includes)) {
      query.includes = q.includes;
    } else {
      query.includes = [q.includes];
    }
  }

  if (q.excludes) {
    if (Array.isArray(q.excludes)) {
      query.excludes = q.excludes;
    } else {
      query.excludes = [q.excludes];
    }
  }

  if (q[API_KEY]) {
    query[API_KEY] = q[API_KEY];
  }

  return query;
}
